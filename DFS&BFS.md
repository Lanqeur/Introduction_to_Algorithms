# 搜索
搜索包括两种基本方法：BFS、DFS。搜索是暴力(Brute Force)法算法思想的具体实现，暴力法编程的主要手段就是搜索：把所有可能的情况列举出来，然后逐一检查，从中找到答案。暴力法简单、直接，利用了计算机强大的计算能力。
DFS和BFS的相同点：都需要暴力搜索所有的结点和路线，也就是说它们的计算量是一样的。
DFS和BFS的区别：使用BFS能方便的找到最短路径，而使用DFS比较困难；使用DFS能搜索到从出口到入口的所有路径，而使用BFS不行；DFS编程比BFS编程简单一些。
在具体编程时，一般用队列这种数据结构来实现BFS，“BFS=队列”；
DFS一般用递归实现，“DFS=递归”。
## DFS基础
### 递归
从形式上看，递归函数是“自己调用自己”，是一个不断重复的过程。
递归的算法思想：把大问题逐步缩小，直到变成最小的同类问题，而最后的小问题的解是已知的，一般是给定的初始条件。当到达最小问题后，再回溯，把小问题的解逐个带给更大的问题，最终最大的问题也得到了解决。所以递归有两个过程：递归前进、递归返回(回溯)。
在递归的过程中，由于大问题和小问题的解决方法完全一样，因此大问题和小问题的代码可以一样。一个递归函数直接调用自己，实现了程序的复用。
### 记忆化搜索
为避免递归时重复计算，可以在子问题得到解决时保存结果，再次需要这个结果时，直接返回保存的结果就行了，不必继续递归。这种存储已经解决的子问题结果的技术称为记忆化(Memoization)。记忆化是递归的常用优化技术，DP常常用到递归，所以记忆化也是DP的关键技术。
### DFS的代码框架
```C++
ans;//答案，用全局变量表示
void dfs(层数，其它参数)
{
    if(出局判断)//到达最底层，或者满足条件退出
    {
        更新答案;//答案一般用全局变量表示
        return;//返回到上一层
    }
    //在进一步DFS之前剪枝
    for(枚举下一层可能的情况)//对每一种情况继续DFS
    if(used[i]==0)//如果状态i没有用过，就可以进入下一层
    {
        used[i]=1;//标记状态i，表示已经用过，在更底层不能再使用
        dfs(层数+1,其它参数);//下一层
        used[i]=0;//恢复状态，回溯时，不影响上一层对这个状态的使用
    }
    return;//返回上一层
}
```
在上述代码中used[i]=1，称为“保护现场”或“占有现场”；
used[i]=0,称为“恢复现场”或“释放现场”。
* “保护现场”的作用是禁止重复使用。当搜索一条从起点到终点的路径时，这条路径上经过的点，不能重复经过，否则就兜圈子了，所以需要对路径上的点“保存现场”，禁止经过它。没有经过的点，或者碰壁后退回的点，都不能“保护现场”，这些点可能后面会进入当前路径；
* “恢复现场”的作用是允许重复使用。当重新搜索新的路径时，方法是从终点或碰壁的点沿着旧路径逐步退回，每退回一个点，就对这个点“恢复现场”，允许新路径重新经过这个点。
### DFS与排列组合
用DFS实现一个关键应用：生成排列。给出一些数，生成它们的排列。在某些场景下，系统排列函数并不适用，需要自行编写代码实现排列。下面给出两种自行编写的DFS代码，设数字是{1,2,3,4,5,...,n}，用递归输出排列。
#### 自写排列算法1
1. 让第一个数不同，得到n个数列。其办法是把第1个数和后面每个数交换。
```
1 2 3 4 5 ... n
2 1 3 4 5 ... n
...
n 2 3 4 5 ... 1
```
以上n个数列，只要第一个数不同，不管后面n-1个数是怎么排列的，这n个数列都不同。
2. 在上面的每个数列中，去掉第一个数，对后面n-1个数进行类似的排列。得到的n-1个数列，只要第一个数不同，不管后面n-2个数是怎么排列的，这n-1个数列都不同。
3. 重复以上步骤，直到用完所有数字。
```C++
int a[]={1,2,3,4,5,6,7,8,9,10,11,12,13};
void dfs(int s,int t)//从第s个数开始到第t个数结束的全排列
{
    if(s==t)//递归结束，产生一个全排列
    {
        for(int i=0;i<=t;i++)cout<<a[i]<<" ";//输出一个排列 
        return;
    }
    for(int i=s;i<=t;i++)
    {
        swap(a[s],a[i]);//把当前第1个数与后面所有数交换位置
        dfs(s+1,t);
        swap(a[s],a[i]);//恢复，用于下一次交换
    }
}
int main()
{
    int n=3;
    df(0,n-1);//前n个数的全排列
}
```
如果需要打印n个数中任意m个数的排列，例如在4个数中取任意3个数的排列，则只需改变dfs()中的两处。
```C++
int a[]={1,2,3,4,5,6,7,8,9,10,11,12,13};
void dfs(int s,int t)//从第s个数开始到第t个数结束的全排列
{
    if(s==3)//递归结束，产生一个全排列
    {
        for(int i=0;i<3;i++)cout<<a[i]<<" ";//输出一个排列 
        return;
    }
    for(int i=s;i<=t;i++)
    {
        swap(a[s],a[i]);//把当前第1个数与后面所有数交换位置
        dfs(s+1,t);
        swap(a[s],a[i]);//恢复，用于下一次交换
    }
}
int main()
{
    int n=4;
    df(0,n-1);//前n个数的全排列
}
```
上面的代码很短很简单，但是不能按从小到大的顺序输出排列，因此这种方法具有一定的局限性。
#### 自写排列算法2
下面的代码能按从小到大的顺序输出排列，前提是a[20]中的数字从小到大排列的，如果不是，就需要先排序。
下面的代码中，用b[]记录一个新的全排列，第一次进入dfs()时，b[0]在n个数中选一个数，第二次进入dfs()时，b[1]在剩下的n-1个数中选一个数，等等。用vis[]记录某个数是否已经被选过，被选过的数不能在后面继续被选。
```C++
int a[20]={1,2,3,4,5,6,7,8,9,10,11,12,13};
bool vis[20];//记录第i个数是否用过
int b[20];//生成的一个全排列
void dfs(int s,int t)
{
    if(s==t)//递归结束，产生一个全排列
    {
        for(int i=0;i<t;i++)cout<<b[i]<<" ";//输出一个排列
        return;
    }
    for(int i=0;i<t;i++)
        if(!vis[i])
        {
            vis[i]=true;
            b[s]=a[i];
            dfs(s+1,t);
            vis[i]=false;
        }
}
int main()
{
    int n=3;
    dfs(0,n);//前n个数的全排列
    return 0;
}
```
如果需要输出n个数中任意m个数的排列：
```C++
int a[20]={1,2,3,4,5,6,7,8,9,10,11,12,13};
bool vis[20];//记录第i个数是否用过
int b[20];//生成的一个全排列
void dfs(int s,int t)
{
    if(s==3)//递归结束，产生一个全排列
    {
        for(int i=0;i<3;i++)cout<<b[i]<<" ";//输出一个排列
        return;
    }
    for(int i=0;i<t;i++)
        if(!vis[i])
        {
            vis[i]=true;
            b[s]=a[i];
            dfs(s+1,t);
            vis[i]=false;
        }
}
int main()
{
    int n=4;
    dfs(0,n);//前n个数的全排列
    return 0;
}
```
#### DFS的复杂度分析
做每道竞赛题时，都应该分析复杂度，看代码是否能在限定的时间和空间内完成运行。设迷宫有n行n列，执行一次dfs()最多需要走遍所有的点，即O(n^2^)；对每个点都执行一次dfs()，则总复杂度是O(n^4^)，如果n很大就会导致严重超时。DFS是暴力搜索技术，也就是说它会搜索所有可能的情况，在n行n列的迷宫中共有n^2^个点，所以DFS的复杂度至少是O(n^2^)，那么还可以进行优化吗？
#### DFS的路径标记
其实可以不用对每一个点都执行一次dfs()，例如从一个点出发，走过一条路径，最后走出了迷宫，那么以这条路径上所有的点为起点，都能走出迷宫；如果走这条路径兜圈子了，则走过这条路径上所有的点都不能走出迷宫。如果有办法对路径进行记录，就能大大减少计算量。
关键是如何标记整个路径。可以用solve[][]标记，如果solve[i][j]=1，则表示点(i,j)能走出去；当solve[i][j]=2时，表示走不出去。由于只需要对迷宫内每个点的solve[][]赋值一次就可以得到答案，所以总复杂度是O(n^2^)，这已经是能达到的最小的复杂度了。
## BFS基础
BFS的原理是“逐层扩散”，从起点出发按层次先后搜索。编程时，BFS用队列实现。由于BFS的特点是逐层搜索，先搜到的层离起点近，所以BFS一般用于求解最短路径问题。
### BFS与最短路径
计算最短路径是BFS的基本应用。BFS是一种很好的查找最短路径的算法，不过它只适合一种情况：任意相邻两点之间的距离相等，一般把这个距离看成1，有时称为1跳。在这种情况下，要查找一个起点到终点的最短距离，BFS是最优的查找最短路径的算法。计算复杂度是O(n+m)，n是图上点的数量，m是边数。如果1跳的距离不是1，那么一条有更多“跳”的路径反而可能比有更少“跳”的路径更短，此时就不能用BFS了，而是需要用Dijkstra、SPFA、Floyd等通用算法。
计算最短路径时存在以下两个问题：
1. 最短路径有多长。要注意最短路径的长度是唯一的；
2. 最短路径经过了哪些点，由于最短路径可能不只一条，所以题目一般不要求输出路径。如果要求，一般输出字典序最小的那条路径。
#### 输出最短路径的简单方法
每扩展到一个点v，都在点v上存储从起点s到点v的完整路径path。到达终点t时，就得到了从起点s到点t的完整路径。这样的缺点是会占用大量空间，因为每个点上都存储了完整的路径。这种方法适合小图。这种路径记录方法称为“简单方法”。
#### 输出最短路径的标准方法
其实可以不用在每个点上存储完整路径，在每个点上记录它的前驱点就够了，这样从终点能一步步回溯到起点，得到一条完整路径。这种路径记录方法称为标准方法。
## 连通性判断
连通性判断是图论中的一个简单问题，给定一张图，图由点和连接点的边组成，要求找到图中互相连通的部分，这是基础的搜索，用DFS或BFS都行。不过，如果N较大，则用DFS可能会因递归深度太大而出错，此时应该用BFS。
### DFS连通性判断
DFS判断连通性的步骤如下：
1. 从图中任意一个点u开始遍历，标记点u已经被搜索过；
2. 递归点u的所有符合连通条件的邻居点；
3. 递归结束，找到了与点u连通的所有点，这是一个连通块；
4. 不与点u连通的、其它没有访问到的点，继续用上述步骤处理，直到找到所有的连通块。
### BFS连通性判断
BFS判断连通性的步骤如下：
1. 从图中任意一个点u开始遍历，把它放进队列中；
2. 弹出队首u，标记点u已经被搜索过，然后搜索点u的邻居点，即与点u连通的点，将其放到队列中；
3. 弹出队首，标记为已被搜索过，然后搜索与它连通的邻居点，放进队列；

继续以上步骤，直到队列为空，此时已经找到一个连通块，其它没有访问到的点，属于另外的连通块，按以上步骤再次处理这些点。最后所有的点都被搜索过，所有连通块也都找到了。
## BFS与判重
BFS的题目很多与判重有关。BFS的原理是逐步扩展下一层，把扩展出来的下一层点放进队列中处理。在任意时刻，队列中只包含相邻两层的点。这两层点会不会太多了？
1. 如果这些点互不相同，那么没有办法，只能把所有点放进队列；
2. 如果这些点有相同的，那么只搜索一次就够了，其它相同的点不用再搜索，此时需要判重。
## 双向广搜
BFS的效率很高，而且在某些情况下还能通过优化得到新的算法，例如双向广搜、优先队列等。这里介绍比较简单的双向广搜：
设想有这样一个搜索场景：有确定的起点s和终点t，并且能把从起点到终点的单向搜索变换为分别从起点和从终点出发的“相遇”问题。
此时可以进行以下优化操作：从起点s(正向搜索)和终点t(逆向搜索)同时开始搜索，当两个搜索产生相同的一个子状态v时就结束搜索。v是相遇点，得到的s-v-t是一条最佳路径，当然，最佳路径可能不止一条。
和普通BFS一样，双向广搜在搜索时并没有“方向感”，“正向搜索”和“逆向搜索”其实是盲目的，它们表示分别从s和t逐层扩散出去，直到相遇为止。
### 如何编程实现双向广搜？
一般用两个队列分别实现正向BFS和逆向BFS。
队列q1用于正向搜索，队列q2用于逆向搜索。如果正向BFS和逆向BFS扩展的下一层数量不同，先处理较小的队列，可以加快搜索速度。
双向广搜的计算量远远小于普通BFS。例如，普通BFS不判重的情况下扩展20层，每层4种状态，那么将会扩展4^20^种状态；而在双向广搜中，假设在第10层相遇，正向搜索和逆向搜索在第10层扩展的状态数量都是4^10^，相比4^20^显然是极大的优化。
## 剪枝
BFS、DFS是暴力法的直接实现，能把所有可能的状态都搜索出来，然后从中找到解。不过，暴力法往往比较低效，很多时间浪费在不必要的计算上。判重技术可以删去不必要的扩展，极大的减少了计算量，它是剪枝技术的一种。
剪枝的关键在于剪枝的判断：剪什么枝、在哪里剪。剪枝是搜索常用的优化手段，常常能把指数级的复杂度优化到近似多项式的复杂度。
BFS的主要剪枝技术是判重，如果搜索到某一层时出现重复的状态，就剪枝；
DFS的剪枝技术较多，有可行性剪枝、搜索顺序剪枝、最优性剪枝、排除等效冗余、记忆化搜索等：
1. 可行性剪枝：对当前状态进行检查，如果当前条件不合法就不再继续，直接返回；
2. 搜索顺序剪枝：搜索树有多个层次和分支，不同的搜索顺序会产生不同的搜索树形式，复杂度也相差很大；
3. 最优性剪枝：在最优化问题的搜索中，如果当前条件不合法就不再继续，直接返回；
4. 排除等效冗余：搜索的不同分支，最后的结果是一样的，那么只搜一个分支就够了；
5. 记忆化搜索：在递归的过程中，有许多分支被反复计算，会大大降低算法的执行效率，用记忆化搜索将已经计算出来的结果保存起来，以后需要用到的时候直接取出结果，避免重复运算，从而提高算法的效率；

虽然总结了这么多有关剪枝的名词，但是用不着记，剪枝的总体思路就是”减少搜索状态“。