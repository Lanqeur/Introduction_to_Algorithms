# 算法
有一个经典的定义：程序=算法+数据结构。算法是解决问题的逻辑、方法、过程，数据结构是数据在计算机中的存储和访问的方式，将两者紧密结合才能解决复杂问题。
算法是对特定问题求解步骤的一种描述，是指令的有限序列。它有以下5个特征：
1. 输入：一个算法有0个或多个输入。程序可以没有输入，但一定要有输出。
2. 输出：一个算法有一个或多个输出。
3. 有穷性：一个算法必须在执行有穷步之后结束，且每一步都在有穷时间内完成。
4. 确定性：算法中每一条指令必须有确切的含义，相同的输入只能对应相同的输出。
5. 可行性：算法描述的操作可以通过将已经有限次来实现。    
## 计算资源
计算机程序运行需要的资源有两种：计算时间和存储时间。资源是有限的，可以根据一个算法对这两种资源的使用程度来衡量该算法的优劣：
* 时间复杂度：代码运行需要的计算时间；
* 空间复杂度：代码运行需要的存储空间。
这两个限制条件非常重要，是检验代码性能的参数。
对于C++题目，如果题目的时间限制为1s，那么内部循环次数n应该控制在1*10^8^次以内。
由于代码的运行时间依赖于计算机性能，不同计算机的运行结果不尽相同，所以直接把运行时间作为判断标准并不准确，用代码的计算次数来衡量代码优劣更加合理，例如代码循环了n次，把它的运行次数记为O(n)，称为计算复杂度的“大O记号”。
### 计算次数和时间复杂度
对于同一个问题常常存在不同的解决方案，有高效的，也有低效的。算法竞赛主要考核的是能否在限定的时间和空间内解决问题。由于算法竞赛时间极为紧张，因此解题速度极为关键，只有尽快完成更多的题目，才有机会取得胜利，在满足限制条件的前提下，用最短时间完成编程任务才是最重要的。
低效算法所需的编程时间往往大大少于高效算法。复制算法比简单算法的逻辑复杂，但是代码不一定比简单算法长，代码长短不是衡量算法难易的标准。
### 数据结构和空间复杂度
存储空间和使用的数据结构有关。有时题目的规模较大，只有使用合适的数据结构，才能存储和访问这些数据。如果代码使用的存储空间超过了题目给出的内存限制，则测试系统返回“MLE”，即Memory Limit Exceeded。
以图为例，图的存储可以使用邻接矩阵，邻接表等数据结构。图的存储需要存储点和边。
* 邻接矩阵用二维数组g[][]存储点和边，要存储n个点和连接n个点的边，这个二维数组能存n个点和n^2^条边，若二维数组使用4字节的int类型，则共需要4n^2^的空间，当n=8000时，4n^2^=256MB，等于题目给定的内存限制。所以邻接矩阵只能用于存储几千个点的小图，如果图的边很稀疏，那么二维数组大部分都被浪费了，存储了很多不存在的边。如果图的边很稠密，边的数量就是O(n^2^)，那么邻接矩阵就是最好的数据结构。
* 邻接表只存储点和连接点的边，不存储那些不存在的边，设为有n个点，m条边，那么邻接表需要的存储空间是n+m，对于稀疏图，n=m，即使n=10^6^，也只用了8MB空间，对于稠密图，m=n^2^，就应直接使用邻接矩阵。由于图大多是稀疏图，所以邻接表更常用。

数据结构和算法是紧密联系的，甚至某些算法必须使用某种数据结构，例如计算最短路径的Floyd算法，它只能使用邻接矩阵，不能用邻接表。
### 算法复杂度概述
衡量算法性能的主要标准是时间复杂度。
时间复杂度比空间复杂度更重要。一个程序的空间复杂度很容易分析，而时间复杂度往往关系到算法的根本逻辑，更能说明一个程序的优劣。因此一般不特别说明，那么提到复杂度一般指的是时间复杂度。
时间复杂度常常用“大O记号”估计，并不需要精确计算。在算法分析中，常数系数被认为是不重要的，因为n可能极大，比常数系数大得多。
一个算法的复杂度可能有以下几种可能的情况：
1. O(1)。计算时间是一个常数，与问题的规模n无关。例如用公式计算时，一次计算的复杂度就是O(1)；哈希算法在常数时间内计算出存储位置；查找矩阵A[ M][N]中查找i列j行的元素，只需访问一次就够了。
2. O(logn)。计算时间是对数，通常是以2为底的对数。每一步计算后，问题的规模变为原来的1/2。例如在一个长度为n的有序数列中查找某个数，用折半查找的方法，只需要logn次就能找到。O(logn)和O(n)没有太大差别，例如n=1*10^7^时，logn<24.
3. O(n)。计算时间随规模n呈线性增长。在很多情况下，这是算法可能达到的最优复杂度，因为对输入的n个数，程序一般都需要对其进行处理，即计算n次。
4. O(nlogn)。这常常是算法能达到的最优复杂度。例如分治法，一般只有O(logn)个步骤，每个步骤对每个数操作一次，所以总复杂度是O(nlogn)。例如n=1*10^6^时，nlogn=2*10^7^.
5. O(n^2^)。一个两重循环的算法，复杂度是O(n^2^)，类似的复杂度有O(n^3^)、O(n^4^)等。
6. O(2^n^)。一般对应集合问题，例如一个集合中有n个数，这些数不分先后，子集共有2^n^个。
7. O(n!)。一般对应排列问题。如果集合中的数分先后，按顺序输出所有的排列，共有O(n!)个。

上面的复杂度可分成两类：
* 一类是多项式复杂度，包括O(1)、O(n)、O(nlogn)、O(n^k^)等，其中k是一个常数；
* 另一类是指数复杂度，包括O(2^n^)、O(n!)等。

如果一个算法的复杂度是多项式复杂度，则称其为高效算法；如果其复杂度是指数复杂度，则称其为低效算法。
竞赛题目一般的限制时间是1s，对应普通计算机的计算速度是每秒几千万次级。上述的时间复杂度可以换算出能解决问题对应的数据规模。如表所示：
数据规模n|O(logn)|O(n)|O(nlogn)|O(n^2^)|O(2^n^)|O(n!)|
|-|-|-|-|-|-|-|
n<=11|√|√|√|√|√|√|
n<=25|√|√|√|√|√|×|
n<=5000|√|√|√|√|×|×|
n<=10^6^|√|√|√|×|×|×|
n<=10^7^|√|√|×|×|×|×|
n>10^7^|√|×|×|×|×|×|
