# 动态规划
和贪心、分治一样，动态规划也是一种解题思路，DP是地道的“计算思维”，非常适合用计算机实现，可以说是专属于计算机学科的计算理论。DP是一种需要学习才能理解的思维方法，像贪心、分治这样的方法，在生活或其它学科中有很多类似的例子，很容易联想和理解。但DP不是，它是一种生活中没有的抽象计算方法，没有学过的人很难自发产生这种思路。
## 动态规划的概念
DP是一种很容易理解的计算思想。有一些问题具有两个特征：重叠子问题、最优子结构。用DP可以高效率的处理具有这两个特征的问题。
### 重叠子问题
子问题是原大问题的小版本，它们的计算步骤完全一样。计算大步骤时，需要多次重复计算小问题，这就是重叠子问题。
一个子问题的多次计算，耗费了大量时间，用DP处理重叠子问题，每个子问题只需要计算一次，从而避免了重复计算，这就是DP效率高的原因。具体的做法是，先分析得到最优子结构，然后用递推或带记忆化搜索的递归进行编程，从而实现高效的计算；
### 最优子结构
最优子结构的意思是，大问题的最优解包含小问题的最优解；可以通过小问题的最优解推导出大问题的最优解。
有些问题用贪心算法不能获得最优解，但这些问题往往能用DP获得最优解，而且效率相当高。
## 动态规划基础
DP有四大基本问题：状态设计、状态转移方程、DP代码实现、滚动数组。
### 状态设计
DP状态：定义二维数组dp[][]，dp[i][j]表示把前i个物品装入容量为j的背包中获得的最大价值；
把每个dp[i][j]都看成一个背包：背包容量为j，装第1~第i个物品。最后得到的dp[N][C]就是问题的答案：把N个物品装进容量为C的背包的最大价值。
在DP题目中，最好把状态命名为dp，这有利于与他人交流，他人一看到dp就知道这是一道DP题目，dp是定义的状态，而不是别的什么。
### 状态转移方程
假设已经递推计算到dp[i][j]，分以下两种情况：
1. 第i个物品的体积比容量j还大，不能被装进容量为j的背包。直接继承前i-1个物品装进容量为j的背包的情况即可，也就是dp[i][j]=dp[i-1][j];
2. 第i个物品的体积比容积j小，能装进背包。又可以分为两种情况：装或者不装第i个物品。
* 装第i个物品：从前i-1个物品的情况推测而来，前i-1个物品是dp[i-1][j]。将第i个物品装进背包后，背包容量减少c[i]，价值增加w[i]，所以有dp[i][j]=dp[i-1][j-c[i]]+w[i];
* 不装第i个物品：有dp[i-1][j];

取两种情况的最大值，状态转移方程如下：
dp[i][j]=max(dp[i-1][j],dp[i-1][j-c[i]+w[i]]);
总结上述分析，0/1背包问题的重叠子问题是dp[i][j]，最优子结构是dp[i][j]的状态转移方程。
算法的复杂度：算法需要计算二维矩阵dp[][]，二维矩阵的大小是O(NC)，每一项的计算时间是O(1)，总时间复杂度是O(NC),空间复杂度是O(NC)。
### DP代码实现
DP的代码有两种方法：递推、记忆化。
处理DP中的大问题和小问题，有两种思路；一种是自上而下(Top-Down)，即先大问题后小问题；另一种是自下而上(Bottom-Up)，即先小问题后大问题。
编程实现DP时，自上而下用带记忆化搜索的递归代码，自下而上用递推代码。两种方法的复杂度是一样的，每个子问题都计算一遍，而且只计算一遍。
* 递推代码：这种自下而上的方法先解决小问题，再递推到大问题，通常通过填写多维表格来完成，编程时用若干for循环语句填表。根据表中的结果，逐步计算出大问题的解决方案。
* 记忆化代码：先考虑大问题，再缩小小问题，递归直接体现了这种思路。为了避免递归时重复计算子问题，可以在子问题解决时就保存结果，需要使用这个结果时，直接返回保存的结果就行了。这种存储已经解决的子问题的结果被称为记忆化。
### 滚动数组
DP的状态方程常常是二维和二维以上的，会占用很多空间。用滚动数组可以大大减少占用空间，它能把二维状态方程的空间复杂度O(n^2^)优化到O(n)，更高维的数组也可以优化后减少一维。
从状态方程dp[i][j]=max(dp[i-1][j],dp[i-1][j-c[i]]+w[i])可以看出,dp[i][]只与dp[i-1][]有关，与前面的dp[i-2][]、dp[i-3][]等都没有关系。这些已经用过的、无用的dp[i-2][],dp[i-3][]等就变得多余了，所以可以复用这些空间，用新的一行覆盖已经无用的一行(滚动)，这样就只需要两行就够了。下面给出滚动数组的两种实现方法：
1. 交替滚动
定义dp[2][j]，用dp[0][]和dp[1][]交替滚动。这种方法的优点是逻辑清晰，代码不易出错，建议初学者采用这种方法。
```C++
int solve(int n,int C)
{
    int now=0,old=1;
    for(int i=1;i<n;i++)
    {
        swap(now,old);
        for(int j=0;j<=C;j++)
        {
            if(c[i]>j)dp[now][j]=dp[old][j];
            else dp[now][i]=max(dp[old][j],dp[old][j-c[i]]+w[i]);
        }
    }
    return dp[now][C];
}
```
2. 自我滚动
用两行交替滚动数组是很符合逻辑的做法，其实还能继续精简：用一个一维的dp[]就够了，让数组两组滚动。
```C++
int solve(int n,int C)
{
    for(int i=1;i<n;i++)
    for(int j=C;j>=c[i];j--)
    dp[j]=max(dp[j],dp[j-c[i]]+w[i]);
    return dp[C];
}
```

经过滚动数组的优化，空间复杂度从O(NC)减少为O(C)。
滚动数组也有缺点，它覆盖了中间转移状态，只留下了最后的状态，因此舍弃了很多信息，导致无法回溯，不能输出具体的方案。
### 最长公共子序列
最长公共子序列(Longest Common Subsequence,LCS)：在给定序列中删去若干元素后得到的序列。子序列和子串是不同的概念，子串的元素在原序列是连续的。给定两个序列X和Y，当另一个序列Z既是X的子序列又是Y的子序列时，称Z是序列X和Y的公共子序列。最长公共子序列是长度最长的公共子序列。
用DP求最长公共子序列，复杂度是O(nm)。
用dp[i][j]表示A序列前i个元素和B序列前j个元素的最长公共子序列的长度。解分为两种情况：
1. 当a[i]=b[j]时，已求得dp[i-1][j-1]即A和B序列前i-1、j-1个元素的最长公共子序列，在其尾部加上a[i]或b[j]即可得到A、B序列前i、j个元素的最长公共子序列。状态转移方程是dp[i][j]=dp[i-1][j-1];
2. 当a[i]!=b[j]时，状态转移方程是dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
### 最长递增子序列
最长递增子序列(Longest Increasing Subsequence,LIS)，给定一个长度为n的数组，找出一个最长的单调递增子序列。
定义状态dp[i]，表示以第i个数结尾的最长递增子序列的长度，状态转移方程如下：
dp[i]=max{dp[j]}+1;(0<j<i)
复杂度:j在0~i变化，复杂度是O(n),i的变化范围的复杂度也是O(n),总复杂度为O(n^2^)。
DP并不是最长递增子序列的最优解，复杂度为O(nlogn)的非DP解法更优，使用二分法。
## 状态压缩DP
状态压缩DP是一个常用的DP技巧，它借助二进制简化了DP操作。
状态压缩DP的应用背景是以集合为状态，且集合可以用二进制数来表示，用二进制数的位运算来处理。
集合问题一般是指数级复杂度的，例如：子集问题，假设元素无先后关系，那么共有2^n^个子集；排列问题，对所有元素进行全排列，共有n！个全排列。
对状态压缩DP这种技巧概括如下：集合的状态(子集或排列)如果用二进制数来表示，并用二进制数的位运算来遍历和操作，那么又简单又快。
由于集合问题本身是指数级复杂度的，所以状态压缩DP的复杂度仍然是指数级的，只能用于求解小规模问题。
实际上，一个数字的位数有限，int类型只有32位，long long类型只有64位，它们只能表示32种或者64种情况。
### 位运算
状态压缩DP用二进制数来表示状态，而二进制数的处理需要用到各种位运算。用位运算可以简便的对集合进行操作：
1. 判断a的第i位(从最低位开始数)是否等于1:(1<<(i-1))&a
2. 把a的第i位改为1:a|(1<<(i-1))
3. 把a的第i位改为0:a&(~(1<<i))
4. 把a的最后一个1去掉:a&(a-1)
## 树形DP
树形DP是非线性DP，是在树这种数据结构上进行的DP：给出一棵树，要求以最少的代价(或取得最大利益)完成给定的操作。通常这类问题的规模较大，如果用暴力法枚举，则效率低，不可取；如果用贪心算法，则不能得到最优解，因此需要用DP。
在树上做DP非常合适，因为树本身有“子结构”性质(树和子树)，具有递归性，符合DP的性质。相比线性DP，树形DP的状态方程更加直观。
由于树的操作一般需要利用递归和搜索，因此要熟练掌握这些基础知识。树的遍历，一般是从根结点往子结点深入，用DFSS编程更简单。
关于树的存储，树也是一种图，图中有两种数据:结点、连接结点的边。存储图一般有3种方法:邻接矩阵、邻接表、链式前向星。
## 数位DP
数位DP用于统计数字的数位，它常用于处理这样的问题:给定一个范围[0,b],问区间内的所有数字中，某个数码一共有多少个。
如果用暴力法求解，就需要逐一检查每个数字，统计数码出现的次数。
这种问题可以用DP解决，一个数字的数位有个位、十位、百位等，可以用DP思想把低位的统计结果记录下来，在高位计算时直接沿用低位的结果，从而提高效率。
