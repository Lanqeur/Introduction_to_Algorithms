# 倍增法
倍增法是和二分法相反的算法，二分法每次缩小为上一次的1/2，倍增法每次扩大一倍，两者都以2的指数减少或增加，效率极高。
二分法与倍增法的应用场景一般和区间操作有关。二分法是缩小区间，最后定位到一个极小的区间，小到这个区间的左右端点重合，解就是这个极小区间的值。所以二分法适用于在一个有序的序列，或者一个有序的曲线上通过二分缩小查找区间，其目的是找到一个特定的数值。
倍增法是扩大区间，例如在大区间上求解和区间查询有关的问题，求区间最大值或最小值。例如区间最值问题(Range Minimum/Maximum Query,RMQ)就是基于倍增法的ST(Sparse Table)算法解决的。
除了在区间上的应用，倍增法也能用于数值的精确计算。如果空间内的元素满足倍增关系，或者能利用倍增关系来计算，那么也能用倍增法求解这些元素的精确值。这种应用有快速幂、最近公共祖先(Least Common Ancestors,LCA)等。
## 如何编程实现倍增法？
大多数基于倍增法的题目是基于二进制划分(一个数以二进制展开)的。一个整数N，它的二进制展开式：
N=a0 * 2^0^+a1 * 2^1^+a2 * 2^2^+...
例如37，它的二进制是100101，第5、2、0位是1，即a5=a2=a0=1，把这几位的权值相加，2^5^+2^2^+2^0^=32+4+1=37。
一个整数n的二进制划分只有logn位，如果要从0增长到n，则可以用1、2、4...2^k^为跳板，快速跳到n，这些跳板只有k=logn个，跳板数量越少，跳跃速度越快。
倍增法的局限性是需要提前计算出第1、2、4...2^k^个跳板，这要求数据是静态不变的，而不是动态变化的，如果数据发生了变化，那么所有跳板都要重新计算，如果要反复重新计算跳板，倍增法就失去了意义。
## 用暴力法解决区间问题
静态空间的RMQ：给定长度为n的静态数列，做m次查询，每次给定L、R<=n，查询[L,R]内的最值。
以区间最小值为例，如果用暴力法搜索区间最小值，逐一比较区间内的每个数，则复杂度为O(n)，需要m次查询，总复杂度是O(mn)，暴力法的效率很低。在题目规模不大的情况下，用不着高效率的ST算法，可以直接用系统函数，也就是暴力法搜索，下面给出例子：
```C++
#include <algorithm>
int main()
{
    int a[7]={5,7,1,2,3,6,9};
    int id=min_element(a+2,a+5)-a;//区间[a+2,a+5)左闭右开，不包括a+5
    cout<<a[id];//输出最小值1
    id=max_element(a+2,a+5)-a;
    cout<<a[id];//输出最大值
    int s=accumulate(a+2,a+5,0);//最后的0表示从0开始累加
    cout<<s;//输出区间和6
    return 0;
}
```
## ST算法
ST算法是求解RMQ的高效算法，适用于静态空间的RMQ查询，ST算法做一次区间查询的复杂度是O(1)，m次查询的复杂度只有O(m)。
ST算法基于一个简单原理：一个大区间如果能被两个小区间覆盖，则大区间的最值可以用两个小区间的最值计算出来。根据以上原理，可以设计以下高效算法：
1. 把整个数列分成很多小区间，并提前计算每个小区间的最值。
2. 对任意一个区间进行最值查询，找到覆盖它的两个小区间，用两个小区间的最值算出答案。

其中最重要的是1，对于分出来的小区间，不仅需要能快速计算出小区间的最值，而且这种分区方法最好能方便2的计算。
### 如何设计出高效的分区方法？
使用基于倍增法的ST算法，效率非常高。1的复杂度是O(nlogn)，2的复杂度是O(1)。
#### 把数列按倍增法分成小区间
对于数列的每个元素，把它从开始的数列分成长度为1、2、4、8……的小区间。
第1组是长度为1的小区间，有n个小区间，每个小区间有1个元素。
第2组是长度为2的小区间，有n个小区间，每个小区间有2个元素。
第3组是长度为4的小区间，有n个小区间，每个小区间有4个元素。
……
共有O(logn)组，每组有n个小区间，共O(nlogn)个区间。
如何高效的计算出每组小区间的最值？每组的小区间的最值可以从前一组递推出来。
定义dp[s][k]，它表示左端点是s，区间长度为2^k^的区间最值，递推关系是dp[s][k]=min{dp[s][k-1],dp[s+1<<(k-1)][k-1]},其中1<<(k-1)表示2^k-1^。
计算所有小区间的最值，即计算出所有的dp[][]，计算复杂度是多少。每一组小区间都需要计算n次，共logn组，共需要计算O(nlogn)个区间，总计算复杂度是o(nlogn)。
#### 查询任意区间的最值
上述分区和分组的方法能高效的实现最值查询：任何区间的最值，都能在O(1)次内通过这些分区计算出来。
查询一个任意[L,R]的最小值，要先找到以L为起点的区间(区间终点小于R)和以R为终点的区间(起点起点大于L)的并集，就是[L,R]。
根据上面的分区方法，有以下结论：以任意元素为起点，有长度为1、2、4……的小区间；以任意元素为终点，它前面也有长度为1、2、4……的小区间。
根据这个结论，可以把需要查询的[L,R]分成两个小区间，且这两个小区间属于同一个组，即以L为起点的小区间和以R为终点的小区间，让这两个小区间首尾相接覆盖[L,R]，区间最值从两个小区间的最值求得。一次查询的复杂度是O(1)。
[L,R]的长度是len=R-L+1.两个小区间长度都是x，令x是比len小的2的最大倍数，有x<=len且2x>=len，这样保证能覆盖。另外需要计算dp[][]，根据dp[s][k]的定义，有2^k^=x。已知len如何求k？
计算公式是k=log2(len)=log(len)/log(2),向下取整，有两种方法：
```C++
int k=(int)(log(double(R-L+1))/log(2.0));//以10为底的库函数log()
int k=log2(R-L+1);//以2为底的库函数log2()
```
最后给出[L,R]最小值的计算公式，等于覆盖它的两个小区间的最小值：
min(dp[L][k],dp[R-(1<<k)+1][k])
用这个公式做一次最值查询，计算复杂度是O(1).
### ST算法的模板代码
ST算法实际上是一个简单算法，下面的模板代码很短。
```C++
const int N=500001;
int n,m;
int a[N],dp[N][40];
void st_init()
{
    for(int i=1;i<=n;i++)//初始化区间长度为1时的值
    dp[i][0]=a[i];
    int p=(int)(log2(double(n));//p是比n小的2的最大倍数
    for(int k=1;k<=p;k++)
    for(int s=1;s+(1<<k)<=n+1;s++)
    dp[s][k]=max(dp[s][k-1],dp[s+1<<(k-1)][k-1]);//z最大值
}
int st_query(int L,int R)
{
    int k=(int)(log2(double(R-L+1)));
    return max(dp[L][k],dp[R-(1<<k)+1][k]);
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>a[i];
    st_init();
    int L,R;cin>>L>>R;
    cout<<st_query(L,R);
    return 0;
}
```
