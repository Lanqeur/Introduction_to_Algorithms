# 排列和组合
排列是暴力枚举的常见操作，有两种情况：
* 输出n个元素的全排列，共n!种。
* 输出n个元素中任意m个的排列，共n!/(n-m)!种。

C++和Python都提供了排列函数，而Java没有。
C++的next_permutation()是全排列函数，只能输出序列中所有元素的全排列。
## 手写排列和组合代码
在某些场景下，不能用系统提供的排列函数，而是需要手写代码实现排列组合。
### 手写排列代码:暴力法
从n个数中m个有n!/(n-m)!种排列，例如从{1,2,3,4}中选4个数的排列，需要写3重循环。
```C++
int s[]={1,2,3,4};
for(int i=0;i<4;i++)
for(int j=0;j<4;j++)
if(j!=i)
for(int k=0;k<4;k++)
if(k!=j&&k!=i)
cout<<s[0]<<" "<<s[1]<<" "<<s[2]<<endl;
```
### 手写组合代码：暴力法
有时需要输出组合，从n个数中选m个，有n!/m!(n-m)!种组合。例如从{1,2,3,4}中选3个数的组合，排列中的数需要分先后，组合中的数不分先后。
```C++
int s[]={1,2,3,4};
for(int i=0;i<4;i++)
for(int j=i+1;j<4;j++)
for(int k=j+1;k<4;k++)
cout<<s[0]<<" "<<s[1]<<" "<<s[2]<<endl;
```
### 手写组合代码：二进制法
一个包含n个元素的集合{a0,a1,a2,...,an-1}，它的子集有{},{a0},{a1},{a2}...{a0,a1,a2,...an-1},共2^n^个。
用二进制的概念进行对照是最直观的，子集正好对应了二进制数。例如n=3的集合{a0,a1,a2}，它的子集与二进制数的关系如表所示：
子集|empty|a0|a1|a1,a0|a2|a2,a0|a2,a1|a2,a1,a0|
|-|-|-|-|-|-|-|-|-|
二进制数|000|001|010|011|100|101|110|111
表中，每个子集对应一个二进制数，二进制数中的每个1对应子集中的某个元素。而且子集中的元素是不分先后的，这正符合组合的要求，这个表也说明子集的数量是2^n^个，因为对应的二进制数的总个数是2^n^。
#### 输出n个数的任意组合(所有子集)
下面的代码通过处理每个二进制数中的1，输出了所有子集：
```C++
int a[]={1,2,3,4,5,6,7,8};
void print_subset(int n)
{
    for(int i=0;i<i(1<<n);i++)
    {
        //i:0~2^n,每个i的二进制数对应一个子集，一次输出一个子集，最后可得到所有子集
        for(int j=0;j<n;j++)//输出一个子集，即输出i的二进制数中所有的1
        if(i&(1<<j))//从i的最低位开始，逐个检查每一位，如果是1，则输出
        cout<<a[j]<<" ";
    }
}
int main()
{
    int n=3;print_subset(n);//输出前n个元素的所有子集
}
```
#### 输出n个数中任意m个数的组合
根据上面生成子集的二进制方法，一个子集对应一个二进制数，一个有m个元素的子集对应的二进制数中有m个1.所以问题转换为查找1的个数为m个二进制数，这些二进制数对应了要输出的子集。
##### 如何判断二进制数中1的个数为m个？
简单的方法是对这个n位的二进制数进行逐位检查，共需要检查n次。
有一个更快的方法可以直接定位二进制数中1的位置，跳过中间的0。这需要一个神奇的操作**k=k&(k-1)**，功能是消除k的二进制数的最后一个1，连续进行这些操作，每次消除一个1，直到二进制数中的1全被消除，操作次数就是二进制数中1的个数。
利用这个操作，可以计算出二进制数中1的个数，用num统计1的个数，具体步骤如下：
1. 用k=k&(k-1)清除k中的最后一个1；
2. num++；
3. 继续上述操作，直至k=0；

在树状数组中也有一个类似的操作，lowbit(x)=x&-x，功能是计算x的二进制数的最后一个1.
C++代码，输出n=4，m=3的组合。
```C++
int a[]={1,2,3,4,5,6,7,8};
void print_set(int n,int m)
{
    for(int i=0;i<(1<<n);i++)
    {
        int num=0,k=i;//num用来统计i中的1的个数，k用来处理i
        while(k)
        {
            k=k&(k-1);//清除k中的最后一个i
            num++;//统计1的个数
        }
        if(num==m)//二进制数中的1有m个，符合条件
        {
            for(int j=0;j<n;j++)
            if(i&(1<<j))
            cout<<a[j]<<" ";
        }
    }
}
int main()
{
    int n=4,m=3;
    print_set(n,m);
}
```