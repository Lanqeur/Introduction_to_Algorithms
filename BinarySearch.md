# 二分法
二分法是一种思路简单、编程容易、效率极高的算法。二分法有整数二分和是实数二分两种应用场景。实数二分的代码好写、不易出错；编写整数二分的代码需要考虑整除的问题，容易在细节处出错。
## 二分法的概念
二分法的概念很简单，每次把搜索范围缩小为上一次的1/2，直到找到答案为止。二分法的效率很高，只需计算log(n)次。下面介绍二分法的模板代码bin_search()函数，这个函数有3个参数：区间左端点left、区间右端点right、二分的中点mid。每次把区间缩小一半，把left或right移动到mid；直到left=right为止，即找到答案所处的位置：
```C++
int a[1000];
int bin_search(int *a,int n,int x)//在数组a中查找数字x，返回位置
{
    int left=0;right=n;
    while(left<right)
    {
        int mid=left+(right-left)/2;
        if(a[mid]>=x)right=mid;
        else left=mid+1;
        cout<<a[mid]<<" ";
    }
    return left;
}
int main()
{
    int n=100;
    for(int i=0;i<n;i++)a[i]=i+1;//赋值，数字1~100
    int test=54;//猜54这个数
    int pos=bin_search(a,n,test);
    cout<<"\n"<<a[pos];
}
```
二分法的作用：二分法可以把一个长度为n的有序序列上O(n)的查找时间优化到O(logn)。
注意应用二分法的前提：序列是有序的，按从小到大或从大到小排序。
无序的序列无法二分，如果是无序的序列，则应该先排序再对其进行二分。然而如果只需要在无序序列上查找一次，则二分法的效率并不高，先排序再二分的复杂度是O(nlogn),如果使用暴力法，直接在无序的n个数里面查找，最多查找n次，复杂度是O(n)的，比先排序再二分快。
如果不是查找一个数，而是查找m个数，那么先排序再做m次二分的计算复杂度是O(nlogn+mlogn),而暴力法的复杂度是O(mn)，此时二分法远好于暴力法。
### 整数二分
整数二分易理解但不易编程，容易出错，下面给出两个例子。
#### 在单调递增序列中查找x或者x的后继
即在单调递增序列a[]中查找某个数x，如果数列中没有x，则查找比它大的下一个数。前面介绍的bin_search()函数就是这个例子的模板代码。
#### 在单调递增序列中查找x或者x的前驱
把模板代码中a[mid]>=x改成a[mid]<=x。
### 实数二分
实数二分不用考虑整数的取整问题，实数二分的模板代码：
```C++
const double eps=1e-7;//精度，如果用for循环，可以不要eps
while(right-left>eps)//for(int i=0;i<100;i++)
{
    double mid=left+(right-left)/2;
    if(check(mid))right=mid;//判定，然后继续二分
    else left=mid;
}
```
代码中给出了while循环和for循环两种玩法：
#### 使用while循环的实数二分
第一行的极小eps用于判断[left,right]是不是足够小，如果left和right相差小于eps，则认为left和right是相等的，eps需要根据题目来设定，**eps实际上决定了二分的次数**。例如区间长度为1，要达到eps=0.001的精度，做10次二分就能实现(1/2^10^=0.001)。第2行用while循环判断eps，过小的eps会导致超时，过大的eps会导致出错。
#### 使用for循环的实数二分
其实不用eps也行，直接进行足够多的二分就好了。第2行用for循环实现，二分100次，最后的[left,right]长度是初始长度的1/2^100^，得到的精度比任何eps都小，right与left的差值已经小的不能再小了。一般循环100次，不过有时候因为题目的逻辑比较复杂，一次for循环内部的计算量很大，所以较大的for循环次数会导致超时，此时应该把100次减少到50次甚至更少。
#### 实数二分的应用
二分法求解方程的根，是常用的计算方法。一次、二次、三次、四次方程有求根方式，可以用公式求解，但是五次以上的方程没有相应的求根公式，此时可以用计算机强大的计算能力一个一个的试来找出答案，某些方程符合二分法的应用条件，可以用二分法来减少试的次数。
