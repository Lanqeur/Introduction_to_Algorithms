# 图论
图是极为常见的数据结构，基于图的图论算法丰富而深刻。图论的基本算法是BFS和DFS，它们是研究图问题的绝佳算法，大多数基于图论高级算法都是从BFS和DFS发展出来的。
## 图的基本概念
图这种抽象模型由点(Vertex)和连接点的边(Edge)组成。很多点和边构成了一个网状结构，从而能方便的描述事物之间的连接关系。
图算法的复杂度显然和点的数量n、边的数量m直接相关。如果一个算法的复杂度能达到线性时间O(n+m)，那这就是图问题中能达到的最好程度了，例如在边长为1的图上用BFS查找最短路径，复杂度是O(n+m)。即使差一点，能达到O(nlogm),O(mlogn)或类似复杂度的算法，也是很好的算法，例如在一般性的图上用Dijkstra算法搜索最短路径，复杂度是O((n+m)logm)。如果算法的复杂度是O(n^2^),O(m^2^),O(mn)或更高，它就不是好算法，例如Floyd算法的复杂度是O(n^3^),Bellman-Ford算法的复杂度是O(nm)，它们都不是高效的算法。
由于复杂度和n、m都有关系，因此n、m的情况对算法的选择有影响，稀疏图和稠密图适用于不同的算法。如果n和m的数量级相同，那就是稀疏图。如果m很大，例如在极端情况下，每两个点之间都有边连接，m=n^2^/2，则此时是极稠密图。
图的基本特征是点和边，图的基本算法是用搜索来处理点和边的关系。用BFS和DFS遍历一个图非常简单。特别是DFS，用递归来搜索图，其编程实现十分简便。图论中的很多算法，例如拓扑排序、强连通分量等，都建立在DFS之上。
图的一个基本问题是连通性检查，判断图中所有点之间是否连通。连通性检查的代码比较简单，例如用DFS检查连通性，只要从一个出发执行DFS，就能找到它连通的点。
## 图的存储
对图的任何操作，都需要基于一个存储好的图。图的存储结构应该是一种有序的存储结构，能让程序很快定位到点u和点v的边(U,v)。通常情况下，计算复杂度为O(1)，即只用一次或几次计算就定位到。
算法竞赛中常用3种数据结构来存储图：邻接矩阵、邻接表、链式前向星。邻接表和邻接矩阵适用于绝大多数情况，链式前向星非常省空间，可应用于极大的图中。
除了上述3种方法，还有一种极简单、极省空间的存储图的方法，就是直接用数组存储起点u、终点v、边长w的三元组{u,v,w}，但是这种方法有一个极大的缺点，无法快速定位点和边，所以应用场景较少。
### 邻接矩阵
这是最简单、最容易操作的存储方法，特别适用于稠密图，图越稠密越好。如果用于稀疏图，则非常浪费空间。
定义int graph[N][N]二维数组来存储图。graph[i][j]的值是点i到j的边的权值。
把边分为两种情况，无向边和有向边，分别对应无向图和有向图。
1. 无向图:graph[i][j]=graph[j][i];
2. 有向图:graph[i][j]!=graph[j][i]。
i和j之间没有边怎么办？定义一个极大值INF，用graph[i][j]=INF表示i和j之间无边。
邻接矩阵的优点如下：
1. 适合稠密图；
2. 代码非常简短，对边的存储、查询、更新等操作又快又简单，只需要一步就能实现访问和修改边。
邻接矩阵的缺点如下：
1. 存储的空间复杂度是O(n^2^)，太高了。用它存稀疏图时，由于graph[i][j]中有大量点是不存在的，所以用邻接矩阵非常浪费空间。当n=10000个点时，空间需要100MB，已经超过了常见算法竞赛的空间限制。
2. 一般情况下不能存储重边。(u,v)之间可能有两条或更多条边，这就是重边。为什么需要重边？因为点与点之间可能需要定义不同的度量，如费用、长度等，它们不能合并为一个度量。有向边(u,v)在矩阵中只能存储一个参数，矩阵本身的局限性使它不能存储重边。不过如果这个参数值只是用来表示边的数量，那么也算存储了重边。
### 邻接表
邻接表是最常用的存储方法，它只存储存在的边，不存储不存在的边，这是它相对邻接矩阵的优点。
邻接表的编程也不麻烦，可以直接使用系统函数来实现，省去了自写邻接表代码的这一步。例如C++中使用STL的vector。
邻接表特别适合于稀疏图。它的优点是存储效率非常高，只需要与边数成正比的空间，存储的空间复杂度为O(n+m);而且能存储重边。缺点是编程比邻接矩阵稍微麻烦一些，访问和修改也慢一些。
```C++
//定义边
struct edge
{
    int from,to,w;//边:起点from,终点to,权值w
    edge(int a,int b,int c){from=a;to=b;w=c;}//对边赋值
};
//初始化
for(int i=1;i<=n;i++)
e[i].clear();
//存边
e[a].push_back(edge(a,b,c));//把边(a,b)存到结点a的邻接表中
//检索结点u的所有邻居
for(int i=0;i<e[u].size();i++)//结点u的邻居有e[u].size()个
{
    ...
}
```
## 拓扑排序
拓扑排序是BFS和DFS的一个简单、直接的应用。从代码上看，拓扑排序几乎就是纯粹的BFS和DFS。一个图能进行拓扑排序的充要条件是它是一个有向无环图。有环图不能进行拓扑排序。
拓扑排序用到了点的出度和入度概念：
* 出度:以点u为起点的边的数量，称为点u的出度；
* 入度:以点v为终点的边的数量，称为点v的入度。

一个点的入度和出度，体现了这个点的先后关系。如果一个点的入度等于0，则说明它是起点，是排在前面的;如果它的出度等于0，则说明它是排在最后的。
拓扑排序结果可以有多个。拓扑排序用BFS或者DFS都能实现，DFS更常用。DFS天生适合做拓扑排序，简单的在图上做一遍DFS，就会返回一个拓扑排序结果。
回顾DFS的原理：沿着一条路径一直搜索到最底层，然后逐层回退。这个过程正好体现了点和点的先后关系，从而解决了拓扑排序问题。
一个有向无环图(Directed Acyclic Graph,DAG),如果只有一个点u是0入度点，那么从u开始DFS，DFS递归返回的就是拓扑排序的结果(是一个逆序)。DFS递归返回的先是最底层的点，它一定0出度点，没有后续点，是拓扑排序的最后一个点；然后逐步回退，最后输出的是起点u;输出的顺序是一个逆序。
为了按正确的顺序输出拓扑排序结果,编程时的处理是定义一个拓扑排序队列list，每次递归输出的时候，就把输出元素插到当前list的最前面;最后从头到尾输出list，得到的就是拓扑排序结果。这实际上是一个栈，直接用STL的stack<int>定义栈也行。
1. 应该以入度为0的点为起点，开始DFS。如何找到入度为0的点？需要找到入度为0的点吗？如果有多个入度为0的点呢？
想象有一个虚拟的点v，它单向连接到所有其它点。这个虚拟点就是图中唯一的0入读点，图中所有其它的点都是它的下一层递归;而且它不会把原图变成环路。从这个虚拟点开始DFS，就可以完成拓扑排序。
实际编程时，并不需要处理这个虚拟点，只要在主程序中把每个点轮流执行一遍DFS即可。这样做相当于显式的递归了虚拟点的所有下一层点。
2. 如果图不是有向无环图，那么能判断吗？
图不是有向无环图，说明图是有环图，不存在拓扑排序。在递归的时候，会出现回退边的情况。
在程序中，可以这样发现回退边:记录每个点的状态，如果dfs()递归到某个点时发现它仍在前面的递归中没有处理完毕，就说明存在回退边，不存在拓扑排序。
## Floyd算法
最短路径问题是广为人知的图论问题。
BFS是一种很不错的最短路径算法，适合一种情况：任意的相邻两点之间的距离相等。
在更多的应用场景里，需要用不同的算法来求解最短路径。
表格见《程序设计竞赛专题挑战教程》p342.
Floyd算法是最简单的最短路径算法，对应代码仅4行且非常易懂，比暴力法更简单易懂。它的效率不高，不能用于大图，都是某些场景下也有自己的优势，难以替代。
Floyd算法是一种“多源”最短路径算法，一次计算能得到图中每一对结点之间(多对多)的最短路径。
### Floyd算法思想
求图上两点i、j之间的最短距离，可以按“从小图到全图”的步骤，在逐步扩大图的过程中计算和更新最短路径，这是DP求解的思路。定义状态为dp[k][i][j],i,j,k是点的编号，范围为1~n。状态dp[k][i][j]表示在包含1~k点的子图上，点对i、j之间的最短路径。当从子图1~k-1扩展到子图1~k时，状态转移方程如下：
dp[k][i][j]=min(dp[k-1][i][j],dp[k-1][i][k]+dp[k-1][k][j])
方程中的dp[k-1][i][j]是子图内的点对i、j的最短路径;dp[k-1][i][k]+dp[k-1][k][i]是经过k点的新路径的长度，即这条路径从i出发，先到k，再从k到终点j。比较不经过k点的最短路径dp[k-1][i][j]和经过k的新路径，较小者就是新的dp[k][i][j]。每次扩展一个新点k时，都能用到1~k-1的结果，从而提高了效率。这就是用DP求解的方法。
当k从1逐步扩展到n时，最后得到的dp[n][i][j]是点对i、j之间的最短路径长度。
若i、j是直连的，初值dp[0][i][j]就是它们的边长;若i、j不是直连的，则将dp[0][i][j]赋值为无限大。
由于i、j是任意点对，所以计算结束后得到了所有点对之间的最短路径。
```C++
for(int k=1;k<=n;k++)//Floyd的三重循环
for(int i=1;i<=n;i++)
for(int j=1;j<=n;j++)//k的循环在i、j循环外面
dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);//比较不经过k和经过k
```
这里把dp[][][]缩小成了dp[][]，用到了滚动数组，因为dp[k][][]只和dp[k-1][][]有关，所以可以省略k这一维。由于k是DP的子问题的”阶段“，即k是从1开始逐步扩大到n的，所以k的循环必须放在i、j循环的外面。三重循环，复杂度是O(n^3^)。
Floyd算法的寻路极为盲目，这是它的效率低于其它算法的原因，与其它最短路径算法相比，Floyd算法有以下特点：
1. 能在一次计算之后求得所有结点之间的最短距离；
2. 代码极其简单，是最简单的最短路径算法。三重循环结束后，所有点对之间的最短路径都得到了；
3. 效率低下，计算复杂度O(n^3^)，只能用于n<300的小规模图；
4. 存图用邻接矩阵dp[][]是最好的、最合理的，不用更省空间的邻接表。因为Floyd算法计算的结果是所有点对之间的最短路径，本身就需要n^2^的空间，所以用邻接矩阵存储最合适；
5. 能判断负圈。若图中有权值为负的边，某个经过这个负边的环路，所有边长相加的长度也是负数，这就是负圈。在负圈上每绕一圈，路径的总长度就更小，从而陷入兜圈子的死循环。使用Floyd算法很容易判断负圈，只要在算法运行过程中出现任意一个dp[i][i]<0，就说明有负圈。因为dp[i][i]是从i出发，经过其它中转点绕一圈回到自己的最短路径，所以如果dp[i][i]<0,就存在负圈；